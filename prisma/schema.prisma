generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
  // Comment out extensions to avoid issues with Prisma Accelerate
  // extensions = [pgvector]
}

/**
 * ===========================
 * Enums
 * ===========================
 */

// UserRole enum removed - no longer needed without orgs

enum PlanTier {
  STARTER // 1 active slot
  PRO // 2 active slots (future)
}

enum SubscriptionStatus {
  trialing
  active
  past_due
  canceled
  unpaid
  incomplete
  incomplete_expired
}

enum RequestStatus {
  BACKLOG
  ACTIVE
  REVIEW
  DONE
  PAUSED
  REJECTED
}

enum ActivityType {
  CREATED
  UPDATED
  STATUS_CHANGED
  COMMENT_ADDED
  ATTACHMENT_ADDED
  SYSTEM_EVENT
}

enum CommentVisibility {
  PUBLIC // visible to client/org
  INTERNAL // visible to you/admin only
}

/**
 * ===========================
 * Core Identity / User
 * ===========================
 */

model User {
  id             String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  // OIDC subject from Kinde
  authProviderId String  @unique
  email          String  @unique
  name           String?
  avatarUrl      String?

  // preferences
  timeZone String? // e.g. "Europe/Rome"
  locale   String? // e.g. "it-IT"

  // Plan and billing info (moved from Org)
  plan            PlanTier @default(STARTER)
  concurrentSlots Int      @default(1) // overrideable

  // Stripe linkage (moved from Org)
  stripeCustomerId String? @unique

  requests        Request[]        @relation("RequestsOwned")
  requestsCreated Request[]        @relation("RequestsCreatedBy")
  comments        RequestComment[]
  activities      Activity[]       @relation("ActivitiesOwned")
  activitiesBy    Activity[]       @relation("ActivitiesBy")
  subscriptions   Subscription[]
  payments        Payment[]
  attachments     Attachment[]

  settings UserSettings?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@index([authProviderId])
  @@index([stripeCustomerId])
}

// Org, OrgMember, and OrgInvite models removed - users are now self-contained

/**
 * ===========================
 * Billing (Stripe Mirror)
 * ===========================
 */

model Subscription {
  id                   String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId               String             @db.Uuid
  stripeSubscriptionId String             @unique
  stripePriceId        String
  status               SubscriptionStatus
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  cancelAtPeriodEnd    Boolean            @default(false)
  canceledAt           DateTime?
  paused               Boolean            @default(false) // pause_collection mirror

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([status])
}

model Payment {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId          String    @db.Uuid
  stripeInvoiceId String    @unique
  amountCents     Int
  currency        String    @db.VarChar(3)
  paidAt          DateTime
  periodStart     DateTime?
  periodEnd       DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([userId, paidAt])
}

/**
 * ===========================
 * Request Queue (Client Work)
 * ===========================
 */

model Request {
  id          String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String        @db.Uuid
  title       String
  description String        @db.Text
  status      RequestStatus @default(BACKLOG)
  priority    Int           @default(3) // 1=high,5=low
  orderIndex  Int           @default(0) // sort within BACKLOG
  previewUrl  String?
  createdById String?       @db.Uuid
  eta         DateTime? // optional SLA target

  user      User  @relation("RequestsOwned", fields: [userId], references: [id], onDelete: Cascade)
  createdBy User? @relation("RequestsCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)

  comments    RequestComment[]
  attachments Attachment[]
  activities  Activity[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  // Enforce ONE ACTIVE per user via partial unique index in SQL (see bottom)

  @@index([userId, status])
  @@index([createdById])
}

model RequestComment {
  id         String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  requestId  String            @db.Uuid
  authorId   String?           @db.Uuid // null if system
  visibility CommentVisibility @default(PUBLIC)
  body       String            @db.Text

  request Request @relation(fields: [requestId], references: [id], onDelete: Cascade)
  author  User?   @relation(fields: [authorId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([requestId])
  @@index([authorId])
}

model Attachment {
  id         String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId     String  @db.Uuid
  requestId  String? @db.Uuid
  url        String  @db.Text
  kind       String? // "image","doc","link"
  uploadedBy String? @db.Uuid

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  request Request? @relation(fields: [requestId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([userId, requestId])
}

/**
 * ===========================
 * Activity / Audit
 * ===========================
 */

model Activity {
  id        String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId    String       @db.Uuid
  requestId String?      @db.Uuid
  type      ActivityType
  meta      Json?        @db.JsonB // diff, from->to, etc.
  actorId   String?      @db.Uuid // null = system/webhook

  user    User     @relation("ActivitiesOwned", fields: [userId], references: [id], onDelete: Cascade)
  request Request? @relation(fields: [requestId], references: [id], onDelete: SetNull)
  actor   User?    @relation("ActivitiesBy", fields: [actorId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([requestId])
  @@index([actorId])
}

/**
 * ===========================
 * Settings
 * ===========================
 */

// OrgSettings model removed - settings moved to UserSettings

model UserSettings {
  id              String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId          String  @unique @db.Uuid
  notifyOnStatus  Boolean @default(true)
  notifyOnComment Boolean @default(true)
  marketingEmails Boolean @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

/**
 * ===========================
 * Webhook Event Log (optional but useful)
 * ===========================
 */

model WebhookEvent {
  id         String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  provider   String // "stripe" | "midday" | etc.
  eventType  String
  externalId String? // stripe event id, etc.
  payload    Json    @db.JsonB
  processed  Boolean @default(false)
  error      String?

  createdAt   DateTime  @default(now())
  processedAt DateTime?

  @@index([provider, eventType])
}
